Instead of exhaustively tracing the states
use the flag diacritics feature.

From start state there are two edges to state N
one labelled "@D.char0@" "a"
and the other labelled "@R.char0.a" (an epsilon edge).
(Actually, all the "really labelled" edges can share a
state where they pass through "@D.char0@" first.

Then from that state "@D.char1@" "b" and "@R.char1.b" etc.

We match (say) "abc" then follow the edges for "de" but fail to match the
outgoing edge (say, "f"). We then follow the edge for [abcdegh?@R.char5.a@@R.char5.b@...] which
emits "@P.char2.x" (for edge labelled x) then rejoins a common state to do
"@R.char7.x" -> "@P.char3.x" / "@D.char7@" -> "@C.char7@" then rejoin then
"@R.char8.x@" -> "@P.char4.x" / "@D.char8@ -> "@C.char8@" then rejoin then
emit "abc" then "@P.char0.d@" "@P.char1.e@"
before branching to the start state again.

The number of flag diacritic vars is one less than the longest string
(ie, if longest string is "abcdef" we match "abcde" then fail "f" without
any partial matches along the way, so we emit "a", then need to set flag
diacritics for "bcde" and the letter which wasn't "f".
If N is the number of entries and M is the longest word and A the alphabet
size, we expect O(NM) states and O(NM) edges for the straightforward match,
then O(AMN) states for backtracking.  Crucially we don't get O(A^2) as a
factor anywhere, but UTF-8 is (probably) still worthwhile because a factor of
4 increase in M is still much cheaper than a factor of 256 increase in A.
Of course maybe the actual A for CJK languages is closer to 4*256 than it
is to 65536.


Sample:

ab -> aa
abcd -> bbbb
cbc -> ccc
ba -> dd

Input: abcbad
